// Comprehensive Testbench for Synchronous FIFO
// Author: FPGA Design Portfolio
// Features:
//   - Multiple test configurations (different WIDTH/DEPTH)
//   - Comprehensive test scenarios
//   - Self-checking with pass/fail reporting
//   - Coverage analysis
//   - Performance benchmarking

`timescale 1ns / 1ps

module sync_fifo_tb;

    // Test parameters - can be overridden from command line
    parameter int WIDTH = 32;
    parameter int DEPTH = 16;
    parameter int ADDR_WIDTH = $clog2(DEPTH);
    
    // Clock and reset
    logic clk;
    logic rst_n;
    
    // DUT interface
    logic                   wr_en;
    logic [WIDTH-1:0]       wr_data;
    logic                   full;
    logic                   rd_en;
    logic [WIDTH-1:0]       rd_data;
    logic                   empty;
    logic [ADDR_WIDTH:0]    count;
    
    // Testbench variables
    logic [WIDTH-1:0]       expected_data_queue[$];
    logic [WIDTH-1:0]       write_data_history[$];
    logic [WIDTH-1:0]       read_data_history[$];
    
    // Statistics
    int unsigned total_tests = 0;
    int unsigned passed_tests = 0;
    int unsigned failed_tests = 0;
    int unsigned writes_completed = 0;
    int unsigned reads_completed = 0;
    
    // Performance metrics
    realtime start_time, end_time;
    real throughput_mbps;
    
    // DUT instantiation
    sync_fifo #(
        .WIDTH(WIDTH),
        .DEPTH(DEPTH)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .wr_en(wr_en),
        .wr_data(wr_data),
        .full(full),
        .rd_en(rd_en),
        .rd_data(rd_data),
        .empty(empty),
        .count(count)
    );
    
    // Clock generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk;  // 100MHz clock
    end
    
    // Waveform dump
    initial begin
        $dumpfile("sim/waves/sync_fifo_waves.vcd");
        $dumpvars(0, sync_fifo_tb);
    end
    
    // Main test sequence
    initial begin
        $display("=== Synchronous FIFO Testbench Started ===");
        $display("Configuration: WIDTH=%0d, DEPTH=%0d, ADDR_WIDTH=%0d", WIDTH, DEPTH, ADDR_WIDTH);
        $display("Time: %0t", $time);
        
        // Initialize
        initialize_signals();
        
        // Reset sequence
        reset_sequence();
        
        // Test suite
        run_test_suite();
        
        // Final report
        final_report();
        
        $finish;
    end
    
    // Initialize all signals
    task initialize_signals();
        $display("[%0t] Initializing signals...", $time);
        wr_en = 0;
        wr_data = 0;
        rd_en = 0;
        rst_n = 1;
    endtask
    
    // Reset sequence
    task reset_sequence();
        $display("[%0t] Applying reset...", $time);
        rst_n = 0;
        repeat(5) @(posedge clk);
        rst_n = 1;
        @(posedge clk);
        
        // Check reset state
        check_condition(empty == 1, "FIFO should be empty after reset");
        check_condition(full == 0, "FIFO should not be full after reset");
        check_condition(count == 0, "Count should be zero after reset");
        
        $display("[%0t] Reset completed", $time);
    endtask
    
    // Main test suite
    task run_test_suite();
        $display("\n=== Starting Test Suite ===");
        
        test_basic_write_read();
        test_full_empty_flags();
        test_count_accuracy();
        test_simultaneous_read_write();
        test_corner_cases();
        test_random_operations();
        test_performance_benchmark();
        test_different_configurations();
        
        $display("\n=== Test Suite Completed ===");
    endtask
    
    // Test 1: Basic write and read operations
    task test_basic_write_read();
        $display("\n--- Test 1: Basic Write/Read Operations ---");
        
        // Write some data
        for (int i = 0; i < 8; i++) begin
            write_single(32'hDEADBEE0 + i);
        end
        
        // Read back and verify
        for (int i = 0; i < 8; i++) begin
            read_and_verify(32'hDEADBEE0 + i, $sformatf("Basic read %0d", i));
        end
        
        $display("Basic write/read test completed");
    endtask
    
    // Test 2: Full and empty flag behavior
    task test_full_empty_flags();
        $display("\n--- Test 2: Full/Empty Flag Testing ---");
        
        // Fill the FIFO completely
        $display("Filling FIFO to capacity...");
        for (int i = 0; i < DEPTH; i++) begin
            write_single(32'hCAFE0000 + i);
            if (i == DEPTH-1) begin
                check_condition(full == 1, "FIFO should be full");
                check_condition(count == DEPTH, "Count should equal DEPTH when full");
            end
        end
        
        // Try to write when full (should be ignored)
        $display("Attempting write when full...");
        write_single(32'hDEADDEAD);
        check_condition(count == DEPTH, "Count should remain DEPTH after write attempt when full");
        
        // Empty the FIFO completely
        $display("Emptying FIFO completely...");
        for (int i = 0; i < DEPTH; i++) begin
            read_and_verify(32'hCAFE0000 + i, $sformatf("Empty test read %0d", i));
            if (i == DEPTH-1) begin
                check_condition(empty == 1, "FIFO should be empty");
                check_condition(count == 0, "Count should be zero when empty");
            end
        end
        
        // Try to read when empty (should return stable data)
        $display("Attempting read when empty...");
        logic [WIDTH-1:0] prev_data = rd_data;
        read_attempt();
        check_condition(rd_data == prev_data, "Read data should remain stable when empty");
        check_condition(count == 0, "Count should remain zero after read attempt when empty");
        
        $display("Full/empty flag test completed");
    endtask
    
    // Test 3: Count accuracy
    task test_count_accuracy();
        $display("\n--- Test 3: Count Accuracy Testing ---");
        
        // Test count during progressive fill
        for (int i = 1; i <= DEPTH/2; i++) begin
            write_single(32'h12340000 + i);
            check_condition(count == i, $sformatf("Count should be %0d after %0d writes", i, i));
        end
        
        // Test count during progressive empty
        for (int i = DEPTH/2; i >= 1; i--) begin
            read_and_verify(32'h12340000 + (DEPTH/2 - i + 1), $sformatf("Count test read %0d", i));
            check_condition(count == i-1, $sformatf("Count should be %0d after read", i-1));
        end
        
        $display("Count accuracy test completed");
    endtask
    
    // Test 4: Simultaneous read and write
    task test_simultaneous_read_write();
        $display("\n--- Test 4: Simultaneous Read/Write Testing ---");
        
        // Pre-fill FIFO with known data
        for (int i = 0; i < DEPTH/2; i++) begin
            write_single(32'hABCD0000 + i);
        end
        
        logic [ADDR_WIDTH:0] initial_count = count;
        
        // Perform simultaneous read and write
        $display("Performing simultaneous read/write operations...");
        for (int i = 0; i < 10; i++) begin
            fork
                write_single(32'hEF000000 + i);
                read_and_verify(32'hABCD0000 + i, $sformatf("Simultaneous test %0d", i));
            join
            check_condition(count == initial_count, "Count should remain constant during simultaneous operations");
        end
        
        $display("Simultaneous read/write test completed");
    endtask
    
    // Test 5: Corner cases
    task test_corner_cases();
        $display("\n--- Test 5: Corner Cases Testing ---");
        
        // Test write/read at boundaries
        $display("Testing boundary conditions...");
        
        // Write to almost full, then one more
        for (int i = 0; i < DEPTH-1; i++) begin
            write_single(32'hBEEF0000 + i);
        end
        
        check_condition(!full, "FIFO should not be full with DEPTH-1 entries");
        write_single(32'hBEEF0000 + DEPTH-1);
        check_condition(full, "FIFO should be full with DEPTH entries");
        
        // Read to almost empty, then one more
        for (int i = 0; i < DEPTH-1; i++) begin
            read_and_verify(32'hBEEF0000 + i, $sformatf("Boundary read %0d", i));
        end
        
        check_condition(!empty, "FIFO should not be empty with 1 entry");
        read_and_verify(32'hBEEF0000 + DEPTH-1, "Final boundary read");
        check_condition(empty, "FIFO should be empty with 0 entries");
        
        $display("Corner cases test completed");
    endtask
    
    // Test 6: Random operations
    task test_random_operations();
        $display("\n--- Test 6: Random Operations Testing ---");
        
        int unsigned num_operations = 1000;
        logic [WIDTH-1:0] test_data;
        
        $display("Performing %0d random operations...", num_operations);
        
        for (int i = 0; i < num_operations; i++) begin
            if ($urandom_range(0, 1) && !full) begin
                // Random write
                test_data = $urandom();
                write_single(test_data);
            end else if (!empty) begin
                // Random read
                read_single();
            end
            
            // Periodically check consistency
            if (i % 100 == 0) begin
                check_condition(count <= DEPTH, "Count should never exceed DEPTH");
                check_condition((count == 0) == empty, "Empty flag should match zero count");
                check_condition((count == DEPTH) == full, "Full flag should match max count");
            end
        end
        
        $display("Random operations test completed");
    endtask
    
    // Test 7: Performance benchmark
    task test_performance_benchmark();
        $display("\n--- Test 7: Performance Benchmark ---");
        
        int unsigned num_transfers = 10000;
        
        $display("Benchmarking %0d transfers...", num_transfers);
        start_time = $realtime;
        
        // Continuous write-read operations
        fork
            // Writer process
            for (int i = 0; i < num_transfers; i++) begin
                while (full) @(posedge clk);
                write_single(i);
            end
            
            // Reader process  
            for (int i = 0; i < num_transfers; i++) begin
                while (empty) @(posedge clk);
                read_single();
            end
        join
        
        end_time = $realtime;
        throughput_mbps = (num_transfers * WIDTH) / ((end_time - start_time) * 1e-9) / 1e6;
        
        $display("Benchmark completed:");
        $display("  Transfers: %0d", num_transfers);
        $display("  Time: %0.2f ns", end_time - start_time);
        $display("  Throughput: %0.2f Mbps", throughput_mbps);
        
        $display("Performance benchmark completed");
    endtask
    
    // Test 8: Different configurations
    task test_different_configurations();
        $display("\n--- Test 8: Configuration Validation ---");
        
        $display("Current configuration validated:");
        $display("  WIDTH: %0d bits", WIDTH);
        $display("  DEPTH: %0d entries", DEPTH);
        $display("  Memory size: %0d bits", WIDTH * DEPTH);
        $display("  Address width: %0d bits", ADDR_WIDTH);
        
        check_condition(ADDR_WIDTH == $clog2(DEPTH), "Address width should match calculated value");
        check_condition((DEPTH & (DEPTH-1)) == 0, "Depth should be power of 2");
        
        $display("Configuration validation completed");
    endtask
    
    // Helper tasks
    task write_single(logic [WIDTH-1:0] data);
        @(posedge clk);
        wr_en = 1;
        wr_data = data;
        expected_data_queue.push_back(data);
        write_data_history.push_back(data);
        @(posedge clk);
        wr_en = 0;
        writes_completed++;
    endtask
    
    task read_single();
        logic [WIDTH-1:0] data;
        @(posedge clk);
        rd_en = 1;
        @(posedge clk);
        data = rd_data;
        rd_en = 0;
        read_data_history.push_back(data);
        reads_completed++;
    endtask
    
    task read_and_verify(logic [WIDTH-1:0] expected, string test_name);
        logic [WIDTH-1:0] actual;
        @(posedge clk);
        rd_en = 1;
        @(posedge clk);
        actual = rd_data;
        rd_en = 0;
        read_data_history.push_back(actual);
        reads_completed++;
        
        if (expected_data_queue.size() > 0) begin
            expected = expected_data_queue.pop_front();
        end
        
        check_condition(actual == expected, 
            $sformatf("%s: Expected 0x%h, Got 0x%h", test_name, expected, actual));
    endtask
    
    task read_attempt();
        @(posedge clk);
        rd_en = 1;
        @(posedge clk);
        rd_en = 0;
    endtask
    
    task check_condition(logic condition, string message);
        total_tests++;
        if (condition) begin
            passed_tests++;
            $display("[PASS] %s", message);
        end else begin
            failed_tests++;
            $display("[FAIL] %s", message);
        end
    endtask
    
    // Final report
    task final_report();
        $display("\n=== Final Test Report ===");
        $display("Configuration: WIDTH=%0d, DEPTH=%0d", WIDTH, DEPTH);
        $display("Total Tests: %0d", total_tests);
        $display("Passed: %0d", passed_tests);
        $display("Failed: %0d", failed_tests);
        $display("Success Rate: %0.1f%%", (passed_tests * 100.0) / total_tests);
        $display("Operations: %0d writes, %0d reads", writes_completed, reads_completed);
        
        if (throughput_mbps > 0) begin
            $display("Performance: %0.2f Mbps", throughput_mbps);
        end
        
        if (failed_tests == 0) begin
            $display("\n*** ALL TESTS PASSED! ***");
        end else begin
            $display("\n*** SOME TESTS FAILED! ***");
        end
        
        $display("Testbench completed at time: %0t", $time);
    endtask

endmodule